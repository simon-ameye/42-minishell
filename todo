____________________________________________
HEREDOC

- sigaux custom
- expand en toutes circonstances (meme dans les single quotes)
- supprimer fichier temporaire (meme en cas de C-c C-v !)
____________________________________________
EXIT

- sleep 2 puis Ctr-C --> check exit value
- set g_exitval after each command (builtin or not)
- define possible exit values in header file ? (via macros/enum)

Comparer

1.
minishell: hghgg
minishell: exit
minishell: echo $?

2.
minishell: hghgg
minishell: exit | exit
minishell: echo $?

3.
minishell: hghgg | exit
minishell: echo $?

4.
minishell: hghgg
minishell: ls hghgg | exit
minishell: echo $?

____________________________________________
GLOBAL VARIABLE

- exit value
- environnement (?)
- shlvl (?)
____________________________________________
SYNTAX

faire preceder command not found de 'minishell:'
____________________________________________
VALGRIND

warning: invalid file descriptor -1 in syscall close()
--> avec 'ls' par ex.

leaks de fd
--> valgrind --track-fds=yes
____________________________________________
ENV/EXPORT

- env n affiche pas les vars sans =
- ordre alphabetique (cf. tester export)
____________________________________________
HISTORIQUE

commandes qui font bugger l'historique:
- export A=a B=b C=c D=d E=e F=f G=g H=h I=i J=j K=k L=l
- echo $A$B$C$D$E$F$G$H$I$J$K$L$M$N$O$P$Q$R$S$T$U$V$W$X$Y$Z
____________________________________________
TODO

- tester 'multi' et 'syntax'
- chevron perd siginfication into both s and d quotes
- dollar  perd signification into s quotes
____________________________________________
TESTS

cat | cat | ls
cat < Makefile > out | grep all
cd / | cd /

Warning ! ouble auotes from env expand should be kept, ex :
arg='"hello"'
<echo $arg> should return  <"hello">
I hope that : execve(ECHOPATH, {["arg"], [], []}) returns "hello"
<asxsax asx as sx| dkmsc | sx |> bugue !!

var='<'
echo $var file

cat < bar | echo "<" | cat <  | echo < bar
___________________________________________

digraph G
{

    subgraph cluster_lexer
    {
        label = "LEXER\n";
        
        l1 [label="GET_PROCS :\ncreate `t_proc` array (nb of pipes + 1)\n"]
        l2 [label="GET_TOKENS : \nDetect words thx to spaces and quotes \n Do not removes quotes"]
    }

    subgraph cluster_parser
    {
        label = "PARSER\nIretates upon `procs` and `tokens`";
        p1 [label="GET_TOKEN_TYPE : \nDetect word, '<', word following '<'... < \n"]
        p2 [label="DOLLAR_EXPAND :\nreplace $text by value in env\nSet token IS_EXPENDED to avoid redirecting expended <\n"]
        p3 [label="REMOVE_QUOTES : \nUOTEsRemove quotes)"]
        p4 [label="GET_FDs :\nOoen + parse files names\n Open all files, set FDs in tokens\n"]
        p5 [label="GET_FUNCTION_TYPE : \ndetect function : 0 for execve, 1 for echo...\n"]
        p6 [label="GET_PATH : \ndetect function path\n only for 0 execve\n"]
    }
    
    subgraph cluster_exec
    {
        label = "EXEC\nExecute functions";
        x0 [label="CREATE_PIPES : \nCreate table of pipes\nSet stream_in and stream_out for procs n and n+1\nSet first proc stream input to 0 and last stream output to 1\n(Pipe() + copy ints in procs)"]
        x1 [label="CREATE_CHILDS : \nLaunch continues in forks or in father based on number of procs and ftype + kill childs\n(Fork())\n waitpid()"]
    
        subgraph cluster_exec_child
        {
            label = "EXEC_CHILD\nExecute functions";
            x2 [label="REDIRECT_IO : \nMaybe there is redirect ? Redirects IO based on Imput and Output (for Childs only)\nClose useless fd\n(Dup2)"]
            x3 [label="EXEC_PROC :\nBased of ftype, launches BUILD_IN or EXEC_PROGRAM\n"]
            x33 [label="BUILD_IN :\nAny build in\n  "]
            x4 [label="EXEC_PROGRAM : \nSets the args according to execve requirements and launches(Execve)"]
        }
    }

        process_data [label="PROCESS_DATA\n\
        string\n\
        tab of tokens\n\
        path (as requested by execve)\n\
        func_type\n\
        fd_in\n\
        fd_out\n\
        stream_in\n\
        stream_out\n\
        is_last\n"]
        
        tokens [label="TOKENS\n\
        Null terminated pointer tab\l\
        char    *word\l\
        int     *is_expanded\l\
        \n\
        "]

    l1 -> l2 -> p1
    p1 -> p2 -> p3 ->p4 -> p5 -> p6
    p6 -> x0
    x0 ->x1 -> x2 -> x3 -> x4
    x3 -> x33
    process_data -> tokens
}





set ignored token doit etre avant remove quotes pour ne pas ignorer :
sameye@e2r4p1:~/temp/msh_tester$ echo A  >>  "$USERR"
bash: : No such file or directory

remove quotes doit etre avant get_function_type pour detecter par exemple "echo"

set _ignored_tokens dit etre avant get function type car
$USERR echo bla
Doit fonctionner

set_ignored tokens doit etre apres dollar_expand pour retirer les expands nulls

get_funct_type doit etre apres dollar expand pour detecter les fonctions expand


get_token_type doit etre apres get_ignored_tokens pour detecter les redirections vers token NULL (ambigous)
Ou alors il faut traiter les ambigous dans open file

IMPOSSIBLE! get_token_type doit etre avant dollar_expand pour ne pas considerer les < comme operateur
Ou alors il faut retenir "has_been_expand" dans le token

get_path doit etre apres get_function_type OBVIOUSLY
get_fds doit etre apres get_token_type OBVIOUSLY


ATTENTION un chevron expand perd sa signification

Ajouter le test de string null dans le open => no such file
Traiter le token ignores (ambigous) dans le open
